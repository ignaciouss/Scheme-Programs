#|
  Author: joshua Harris
  Student #: 101091864
  ============================================================
  |                      Assigment#2                         |
  ============================================================
|#
(newline)
(newline)
(display "            Author: Joshua Harris                  Student #: 101091864")
(newline)
(display "            ============================================================")
(newline)
(display "            |                      Assigment#2                         |")
(newline)
(display "            ============================================================")
(newline)
(newline)
(display " Question 1 a")
(newline)
(display "(x/y2+2y)/3 . Use this formula to implement a cube-root procedure analogous to the square-root procedure from the")
(newline)
(display "lecture notes. Your code should use nested functions and free variables wherever possible.")
(newline)
(display "Here is the function")
(newline)
(display"(define (cuberoot x)")
(newline)
(display"  (define (cube y)(* y y y))")
(newline)
(display"  (define (square g) (* g g))")
(newline)
(newline)
(display"  (define (good-enough? guess x)")
(newline)
(display"    (< (abs (- (cube guess x)) 0.001)))")
(newline)
(newline)
(display"  (define (improve guess x)")
(newline)
(display"    (/ (+ (/ x (square guess))(* 2 guess)) 3))")
(newline)
(display"  (define (cubeRoot-iteration guess x)")
(newline)
(display"    (if (good-enough? guess x)")
(newline)
(display"         guess")
(newline)
(display"          (cubeRoot-iteration (improve guess x) x)))")
(newline)
(display"    (cubeRoot-iteration 1.0 x))")
(newline)
(newline)


;cube root function


(define (cuberoot x)
  (define (cube y)(* y y y))
  (define (square g) (* g g))

  (define (good-enough? guess x)
    (< (abs (- (cube guess) x)) 0.001))

   (define (improve guess x)
     (/ (+ (/ x (square guess))(* 2 guess)) 3))

   (define (cubeRoot-iteration guess x)
     (if (good-enough? guess x)
          guess
          (cubeRoot-iteration (improve guess x) x)))

      (cubeRoot-iteration 1.0 x))
  
;cube root test
(display" (cuberoot 0) Expected 0. Actual:   ")(cuberoot 0)
(newline)
(display" (cuberoot 1) Expected 1. Actual:   ")(cuberoot 1)
(newline)
(display" (cuberoot 8) Expected 2. Actual:   ")(cuberoot 8)
(newline)
(display" (cuberoot 64) Expected 4. Actual:   ")(cuberoot 64)
(newline)
(newline)

;1b
(display"(define (cuberoot x)")
(newline)
(display"  (define (cube y)(* y y y))")
(newline)
(display"  (define (square g) (* g g))")
(newline)
(newline)
(display"  (define (good-enough? guess x)")
(newline)
(display"    (< (abs (- (cube guess x)) 0.001)))")
(newline)
(newline)
(display"  (define (improve guess x)")
(newline)
(display"    (/ (+ (/ x (square guess))(* 2 guess)) 3))")
(newline)
(newline)
(display" (define (new-if predicate consequent alternate)")
(newline)
(display"     (cond (predicate consequent)")
(newline)
(display"           (else alternate)))")
(newline)

(display"  (define (cubeRoot-iteration guess x)")
(newline)
(display"    (new-if (good-enough? guess)")
(newline)
(display"         guess")
(newline)
(display"          (cubeRoot-iteration (improve guess x) x)))")
(newline)
(display"    (cubeRoot-iteration 1.0 x))")
(newline)


(newline)
(display "After running the the program with the new if statment, It will indefinitley run and around out memory")
(newline)
; Question 2
(newline)
(display " Question 2 a")
(newline)
(display "Write a higher-order procedure called product analogous to sum procedure from lecture. The procedure should")
(newline)
(display"(product 1 5 (lambda(x)x)(lambda(x)(+ x 1))) â†’ 120")
(newline)


(define (product a b term next)
  (if (> a b)
      1
      (* (term a)
         (product (next a) b term next))))

(newline)
(display "product function")
(newline)
(newline)
(display"(define (product a b term next)")
(newline)
(display"  (if (> a b)")
(newline)
(display"      1")
(newline)
(display "      (* (term a) ")
(newline)
(display"       (product (next a) b term next)))) ")
(newline)
(newline)
(display "TEST CASES")
(newline)
(display"(product 1 5 (lambda(x) x) (lambda(x) (+ x 1)))   Expectd: 120  Result : ")
(product 1 5 (lambda(x) x) (lambda(x) (+ x 1)))
(display"(product 1 9 (lambda(x) x) (lambda(x) (+ x 1)))   Expectd: 362880  Result : ")
(product 1 9 (lambda(x) x) (lambda(x) (+ x 1)))
(display"(product 1 1 (lambda(x) x) (lambda(x) (+ x 1)))   Expectd: 1  Result : ")
(product 1 1 (lambda(x) x) (lambda(x) (+ x 1)))
(display"(product 0 5 (lambda(x) x) (lambda(x) (+ x 1)))   Expectd: 0  Result : ")
(product 0 5 (lambda(x) x) (lambda(x) (+ x 1)))
(newline)
(newline)



;2B
(display"Question 2 b")
(newline)
(display"Rewrite your solution to the previous problem using an iterative process. Call this procedure (product-it)")
(newline)
(newline)
(display "produce-it function")
(newline)
(display "(define (product-it a b)")
(newline)
(display "  (define (product-iterative product counter )")
(newline)
(display "      (if (> counter b)")
(newline)
(display "          product ")
(newline)
(display "          (product-iterative (* product (abstract counter)) (+ counter 1))))")
(newline)
(display "    (product-iterative a 1))")
(newline)

(define (product-it a b)
  (define (product-iterative product counter  )
    (if (> counter b)
         product 
        (product-iterative (* product counter) (+ counter 1))))
  (product-iterative a 1))

(display "test cases")
(newline)
(display "(produce-it 1 5)   Expected: 120  Actual: ")(product-it 1 5)
(newline)
(display "(produce-it 1 10    Expected:3628800     Actual:  ")(product-it 1 10)
(newline)
(display "(produce-it 10 20   Expected:24329020081766400000     Actual:  ")(product-it 10 20)
(newline)
(display "(produce-it 0 5     Expected:0   Actual:  ")(product-it 0 5)
(newline)


(newline)
(newline)
(display "Question 2c  Parti.")
(newline)
(newline)
(display " Using your solution to either of the previous problems, produce the given PI notations below")
(newline)
(display "function")
(newline)
(display "(define (product-it2 a b)")
(newline)
(display "  (define (product-iterative product counter )")
(newline)
(display "    (define (abstract c) (+ (* c c c) c ))")
(newline)
(display "      (if (> counter b)")
(newline)
(display "          product ")
(newline)
(display "          (product-iterative (* product (abstract counter)) (+ counter 1))))")
(newline)
(display "    (product-iterative a 1))")
(newline)

(define (product-it2 a b)
  (define (product-iterative product counter )
    (define (abstract c) (+ (* c c c) c ))
      (if (> counter b)
         product 
        (product-iterative (* product (abstract counter)) (+ counter 1))))
  (product-iterative a 1))

;;test
(display"i. produce-it 1 25    Expected value :1319158   Actual : ")(product-it2 1 25)
(newline)
(newline)
(display"Part ii. ")
(newline)
(display "function")
(newline)
(newline)
(display "(define (product-it3 a b)")
(newline)
(display "  (define (product-iterative product counter )")
(newline)
(display "    (define (square g)(* g g))")
(newline)
(display "    (define (abstract c) (square (+ (* 2 c) 1)))")
(newline)
(display "      (if (> counter b)")
(newline)
(display "          product ")
(newline)
(display "          (product-iterative (* product (abstract counter)) (+ counter 1))))")
(newline)
(display "    (product-iterative a 1))")
(newline)

(define (product-it3 a b)
  (define (product-iterative product counter )
    (define (square g)(* g g))
    (define (abstract c) (square (+ (* 2 c) 1)))
    (if (> counter b)
         product 
        (product-iterative (* product (abstract counter)) (+ counter 1))))
  (product-iterative a 1))


;test
(display " (produce-it3 1 10)  Expected :189043   Actual: ")(product-it3 1 10)

(newline)
(display"Part iii.")
(newline)



; Expected output for part 3 25064
;Question 3
(newline)
(newline)
(display "Question 3 a")
(newline)
(display "Write a procedure called (palindrome? s) that takes a string s as argument and returns true")
(newline)
(display "(#t) if s is palindrome.")
(newline)
(display"(define (letter direction word index)")
(newline)
(display"  (define len (string-length word))")
(newline)
(display"  (if (equal? direction 'right')string-ref index)")
(newline)
(display"  (if (equal? direction 'left')string-ref (- len index))")
(newline)
(newline)
(display"(define (palindrom? s)")
(newline)
(display"  (define len (string-length s)) ")
(newline)
(display"  (define halfEven (/ len 2))")
(newline)
(display"  (define (palin-it index)")
(newline)
(display"    (define rightL (letter 'left' s index ))")
(newline)
(display"    (define leftL (letter 'right' s index ))")
(newline)
(display"  (if (even? len)")
(newline)
(display"      (if (and (> index halfEven)(equal? rightL leftL))")
(newline)
(display"    (plain-it leftL rightL (+ index 1))")
(newline)
(display"      (#f))")
(newline)
(display"    (if (and (> index halfOdd)(equal? rightL leftL))")
(newline)
(display"    (plain-it leftL rightL (+ index 1))")
(newline)
(display"     (#f)")
(newline)
(display"      )))")
(newline)
(display"     (plain-it 0))")
(newline)
(display"     (palindrom? 'racecar')")
(newline)
(display"")

#|
(define (letter direction word index)
  (define len (string-length word))
  (if (equal? direction "right")string-ref index)
  (if (equal? direction "left")string-ref (- len index))
  )

(define (palindrom? s)
  (define len (string-length s))    ;len as length of word
  (define halfEven (/ len 2))
  (define halfOdd (/ (- len 1) 2))
  (define (palin-it index)
    (define rightL (letter "left" s index ))     ; setting right letter to comapare
    (define leftL (letter "right" s index ))     ;setting left ltter to compare
    (if (even? len)
        (if (and (> index halfEven)(equal? rightL leftL))
          (plain-it leftL rightL (+ index 1))
        (#f))
        (if (and (> index halfOdd)(equal? rightL leftL))
          (plain-it leftL rightL (+ index 1))
        (#f)
        )))
   (plain-it 0))
 (palindrom? "racecar")
    
|#

;Queston 4 
(display "Question 4 ")
(newline)
(newline)
(newline)
(display"(define (f n)")
(newline)
(display"  (cond ((< n 3) n)")
(newline)
(display"     (else (+ (f (- n 1))")
(newline)
(display"            (* 2 (f (- n 2)))")
(newline)
(display"            (* 3 (f (- n 3)))))))")
(newline)

(define (f n)
    (cond ((< n 3) n)
       (else (+ (f (- n 1))(* 2 (f (- n 2)))(* 3 (f (- n 3)))))))

;test case
(newline)
(display "(f 5)")(f 5)
(newline)
(display "Substitution model")
(newline)
(newline)
(display"(f 5)")
(newline)
(display"(+ (f (- 5 1))(* 2 (f (- 5 2)))(* 3 (f (- 5 3))))")
(newline)
(display"(+ (f 4) (* 2 (f 3))(* 3 (f 2)))")
(newline)
(display"(+ (f 4) (* 2 (f 3))(* 3 2))")
(newline)
(display"(+ (f 4) (* 2 (f 3))6)")
(newline)
(display"(+ (f 4) (* 2 (+ (f (- 3 1)) (* 2 (f (- 3 2))) (* 3 (f (- 3 3)))))6)")
(newline)
(display"(+ (f 4) (* 2 (+ 2 2))6)")
(newline)
(display"(+ (f 4) (* 2 4)6)")
(newline)
(display"(+ (f 4) 8 6)")
(newline)
(display"(+ (+ (f (- 4 1)) (* 2 (f (- 4 2))) (* 3 (f (- 4 3)))) 8 6)")
(newline)
(display"(+ (+ (f 3) (* 2 (f 2)) (* 3 (f 1))) 8 6)")
(newline)
(display"(+ (+ (f 3) (* 2 2) (* 3 1)) 8 6)")
(newline)
(display"(+ (+ (+ (f (- 3 1)) (* 2 (f (- 3 2))) (* 3 (f (- 3 3)))) 4 3) 8 6)")
(newline)
(display"(+ (+ (+ (f 2) (* 2 (f 1)) (* 3 (f 0))) 4 3) 8 6)")
(newline)
(display"(+ (+ (+ 2 2) 4 3) 8 6)")
(newline)
(display"(+ (+ 4 4 3) 8 6)")
(newline)
(display"(+ 11 8 6)")
(newline)
(display"25")
(newline)
(display"")



;subsitution model
;f(5)
;(+ (f (- 5 1))(* 2 (f (- 5 2)))(* 3 (f (- 5 3))))
;(+ (f 4) (* 2 (f 3))(* 3 (f 2)))
;(+ (f 4) (* 2 (f 3))(* 3 2))
;(+ (f 4) (* 2 (f 3))6)
;(+ (f 4) (* 2 (+ (f (- 3 1)) (* 2 (f (- 3 2))) (* 3 (f (- 3 3)))))6)
;(+ (f 4) (* 2 (+ 2 2))6)
;(+ (f 4) (* 2 4)6)
;(+ (f 4) 8 6)
;(+ (+ (f (- 4 1)) (* 2 (f (- 4 2))) (* 3 (f (- 4 3)))) 8 6)
;(+ (+ (f 3) (* 2 (f 2)) (* 3 (f 1))) 8 6)
;(+ (+ (f 3) (* 2 2) (* 3 1)) 8 6)
;(+ (+ (+ (f (- 3 1)) (* 2 (f (- 3 2))) (* 3 (f (- 3 3)))) 4 3) 8 6)
;(+ (+ (+ (f 2) (* 2 (f 1)) (* 3 (f 0))) 4 3) 8 6)
;(+ (+ (+ 2 2) 4 3) 8 6)
;(+ (+ 4 4 3) 8 6)
;(+ 11 8 6)
;25


(newline)
(newline)
(display "4b")
(newline)
(display "function")
(newline)
(newline)
(display"(define (fb n)")
(newline)
(display"   (cond((< n 3)n)")
(newline)
(display"       (else (iterator 2 1 0 n))))")
(newline)
(newline)
(display"(define (iterator x y z counter)")
(newline)
(display"   (if (< counter 3) x")
(newline)
(display"       (iterator (+ x (* 2 y) (* 3 z)) x y ")
(newline)
(display"                 (- counter 1))))")
(newline)
(newline)


(define (fb n)
  (cond((< n 3)n)
       (else (iterator 2 1 0 n))))
  
(define (iterator x y z counter)
  (if (< counter 3) x
      (iterator (+ x (* 2 y) (* 3 z)) x y 
              (- counter 1))))


(display"Test case")
(newline)
(display"(fb 5)  Expected: 25  Actual:  ")
(fb 5)

;Question 5 a
(newline)
(newline)
(newline)
(display "Question 5 a")
(newline)
(display"Write a procedure that computes elements of Pascal's triangle given row and column indices. ")
(newline)
(display"Any invalid indices should return a value of 0.")

(display "function")
(newline)
(display"(define (pascals x y)")
(newline)
(display"  (if (and (>= x y) (and (>= y 0) (>= x 0)))")
(newline)
(display"      (if (or (= y 0) (= y x))")
(newline)
(display"           1")
(newline)
(display"           (+ (pascals (- x 1) (- y 1))")
(newline)
(display"            (pascals (- x 1) y)))")
(newline)
(display"        0))")

(define (pascals x y)
  (if (and (>= x y) (and (>= y 0) (>= x 0)))
      (if (or (= y 0) (= y x))
          1
          (+ (pascals (- x 1) (- y 1))
             (pascals (- x 1) y)))
      0))

(newline)
(display "Testcases  ")
(newline)
(newline)
(display"(pascals 0 0)  Expected: 1 Actual: ")(pascals 0 0)
(newline)
(display "(pascals 2 0) Expected: 1 Actual: ")(pascals 2 0)
(newline)
(display "(pascals 2 1) Expected: 2 Actual: ")(pascals 2 1)
(newline)
(display "(pascals 4 2) Expected: 6 Actual: ")(pascals 4 2)


;Question 5 b
(newline)
(newline)
(newline)
(display "Question 5 b")
(newline)
(display"Using your solution to the previous part, write a procedure (printTriangle n) that prints n rows ")
(newline)
(display"of Pascal's triangle to the screen.")
(newline)
(newline)
(display"function ")

(newline)
(display"(define (printIndex x y) (display (pascals x y)))   ;print pascals number")
(newline)
(newline)
(display"(define (printTri-Num line)     ; will bring the rows")
(newline)
(display"   (define (index-it index)")
(newline)
(display"      (if (> index line)")
(newline)
(display"         0")
(newline)
(display"       (begin")
(newline)
(display"       (printIndex line index)")
(newline)
(display"       (index-it (+ index 1)))))")
(newline)
(display"     (index-it 0 ))")

(newline)
(newline)
(display"(define (printTriangle lineNum)")
(newline)
(display"  (define (printTri-Line counter)")
(newline)
(display"    (if (> counter lineNum)")
(newline)
(display"        (newline)")
(newline)
(display"     (begin")
(newline)
(display"       (printTri-Num counter)")
(newline)
(display"       (newline)")
(newline)
(display"       (printTri-line (+ counter 1)))))")
(newline)
(display"(printTri-line 0))")
(newline)
(define (printIndex x y) (display (pascals x y)))

(define (printTri-Num line)
  (define (index-it index)
    (if (> index line)
      0
    (begin
     (printIndex line index)
     (index-it (+ index 1)))))
  (index-it 0 ))

(define (printTriangle lineNum)
  (define (printTri-Line counter)
   (if (> counter lineNum)
       (newline)
    (begin
      (printTri-Num counter)
      (newline)
     (printTri-line (+ counter 1)))))
  (printTri-line 0))

;test cases

(newline)
(display" (printTriangle 0) Expected: 1  Actual: ")(newline)(printTriangle 0)
(newline)
(display" (printTriangle 1)Actual: ")(newline)(printTriangle 1)
(newline)
(display" (printTriangle 4)Actual: ") (newline)(printTriangle 4)
(newline)
(display" (printTriangle 7) Actual: ")(newline)(printTriangle 7)








  




 